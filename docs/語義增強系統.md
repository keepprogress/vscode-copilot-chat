# èªç¾©å¢å¼·ç³»çµ± (Semantic Enhancement)

## ğŸ¯ ç³»çµ±æ¦‚è¿°

èªç¾©å¢å¼·ç³»çµ±æ˜¯ VS Code Copilot Chat çš„æ™ºèƒ½æœç´¢å’Œç†è§£æ ¸å¿ƒï¼Œå®ƒä½¿ç”¨å…ˆé€²çš„è‡ªç„¶èªè¨€è™•ç†æŠ€è¡“ï¼ŒåŒ…æ‹¬å‘é‡åµŒå…¥ã€èªç¾©æœç´¢å’Œæ™ºèƒ½åŒ¹é…ç®—æ³•ï¼Œå°‡ç”¨æˆ¶çš„è‡ªç„¶èªè¨€æŸ¥è©¢è½‰æ›ç‚ºç²¾ç¢ºçš„ä»£ç¢¼ç†è§£å’Œç›¸é—œå…§å®¹ç™¼ç¾ï¼Œå¤§å¹…æå‡ AI åŠ©æ‰‹çš„ç†è§£èƒ½åŠ›å’Œå›ç­”æº–ç¢ºæ€§ã€‚

## ğŸ”„ ç³»çµ±æ¶æ§‹æµç¨‹åœ–

```mermaid
flowchart TD
    A[ç”¨æˆ¶æŸ¥è©¢è¼¸å…¥] --> B[æŸ¥è©¢é è™•ç†å™¨]
    B --> C[èªç¾©åˆ†æå™¨]
    
    C --> D[å‘é‡åµŒå…¥ç”Ÿæˆ]
    C --> E[é—œéµè©æå–]
    C --> F[æ„åœ–è­˜åˆ¥]
    
    D --> G[å‘é‡æ•¸æ“šåº«æŸ¥è©¢]
    E --> H[TF-IDF æœç´¢]
    F --> I[ä¸Šä¸‹æ–‡æ“´å±•]
    
    G --> J[èªç¾©ç›¸ä¼¼åº¦è¨ˆç®—]
    H --> K[é—œéµè©åŒ¹é…è©•åˆ†]
    I --> L[æ„åœ–æ¬Šé‡èª¿æ•´]
    
    J --> M[æ··åˆæœç´¢å¼•æ“]
    K --> M
    L --> M
    
    M --> N[çµæœé‡æ’åºç®—æ³•]
    N --> O[èªç¾©èšé¡åˆ†æ]
    O --> P[ç›¸é—œæ€§è©•åˆ†]
    
    P --> Q{çµæœè³ªé‡æª¢æŸ¥}
    Q -->|è³ªé‡ä¸è¶³| R[æŸ¥è©¢æ“´å±•]
    Q -->|è³ªé‡è‰¯å¥½| S[æœ€çµ‚çµæœè¼¸å‡º]
    
    R --> T[åŒç¾©è©æ“´å±•]
    R --> U[ä¸Šä¸‹æ–‡è£œå……]
    T --> C
    U --> C
    
    S --> V[çµæœå¾Œè™•ç†]
    V --> W[æ‘˜è¦ç”Ÿæˆ]
    V --> X[é«˜äº®é—œéµä¿¡æ¯]
    
    W --> Y[å‚³éçµ¦ Prompt æ§‹å»ºå™¨]
    X --> Y
```

## ğŸ§© æ ¸å¿ƒçµ„ä»¶

### 1. å‘é‡åµŒå…¥å¼•æ“
**ä½ç½®**: `src/platform/embedding/`

**åŠŸèƒ½**:
- å°‡ä»£ç¢¼å’Œæ–‡æœ¬è½‰æ›ç‚ºé«˜ç¶­å‘é‡è¡¨ç¤º
- æ”¯æŒå¤šç¨®åµŒå…¥æ¨¡å‹ (text-embedding-3-small ç­‰)
- å¯¦ç¾èªç¾©ç›¸ä¼¼åº¦è¨ˆç®—

**é—œéµæ–‡ä»¶**:
- `embeddingProvider.ts` - åµŒå…¥æä¾›è€…æ¥å£
- `githubEmbeddingsComputer.ts` - GitHub åµŒå…¥è¨ˆç®—å™¨

### 2. èªç¾©æœç´¢æä¾›è€…
**ä½ç½®**: `src/extension/workspaceSemanticSearch/`

**åŠŸèƒ½**:
- å¯¦ç¾ VS Code AI æ–‡æœ¬æœç´¢æ¥å£
- æä¾›è‡ªç„¶èªè¨€ä»£ç¢¼æœç´¢èƒ½åŠ›
- æ”¯æŒèªç¾©é‡æ’åºå’Œçµæœå„ªåŒ–

**é—œéµæ–‡ä»¶**:
- `semanticSearchTextSearchProvider.ts` - ä¸»è¦æœç´¢æä¾›è€…
- `semanticSearchContribution.ts` - æœç´¢è²¢ç»è¨»å†Š

### 3. å·¥ä½œå€å¡Šæœç´¢ç³»çµ±
**ä½ç½®**: `src/platform/workspaceChunkSearch/`

**åŠŸèƒ½**:
- å°‡å¤§å‹æ–‡ä»¶åˆ†å‰²ç‚ºå¯æœç´¢çš„ä»£ç¢¼å¡Š
- å¯¦ç¾æ··åˆæœç´¢ç­–ç•¥ (TF-IDF + èªç¾©)
- æ”¯æŒå¢é‡ç´¢å¼•å’Œå¿«å–å„ªåŒ–

**é—œéµæ–‡ä»¶**:
- `workspaceChunkSearchService.ts` - æœç´¢æœå‹™ä¸»æ§åˆ¶å™¨
- `workspaceChunkEmbeddingsIndex.ts` - å‘é‡ç´¢å¼•ç®¡ç†
- `tfidfWithSemanticChunkSearch.ts` - æ··åˆæœç´¢å¯¦ç¾

### 4. è§£æå™¨æœå‹™
**ä½ç½®**: `src/platform/parser/`

**åŠŸèƒ½**:
- ä»£ç¢¼èªæ³•åˆ†æå’Œçµæ§‹è§£æ
- æå–ä»£ç¢¼èªç¾©ä¿¡æ¯å’Œç¬¦è™Ÿé—œä¿‚
- æ”¯æŒå¤šç¨®ç¨‹å¼èªè¨€è§£æ

## ğŸ’¡ æ ¸å¿ƒæŠ€è¡“å¯¦ç¾

### 1. å‘é‡åµŒå…¥ç”Ÿæˆ

```typescript
interface EmbeddingProvider {
    // ç”Ÿæˆæ–‡æœ¬åµŒå…¥å‘é‡
    computeEmbedding(text: string): Promise<number[]>;
    
    // æ‰¹é‡ç”ŸæˆåµŒå…¥å‘é‡
    computeEmbeddings(texts: string[]): Promise<number[][]>;
    
    // è¨ˆç®—å‘é‡ç›¸ä¼¼åº¦
    computeSimilarity(vector1: number[], vector2: number[]): number;
}

class GithubEmbeddingsComputer implements EmbeddingProvider {
    async computeEmbedding(text: string): Promise<number[]> {
        // ä½¿ç”¨ GitHub/OpenAI API ç”ŸæˆåµŒå…¥å‘é‡
        const response = await this.apiClient.post('/embeddings', {
            model: 'text-embedding-3-small',
            input: text,
            dimensions: 1536
        });
        
        return response.data.embedding;
    }
}
```

### 2. èªç¾©ç›¸ä¼¼åº¦è¨ˆç®—

```typescript
class SemanticSimilarity {
    // é¤˜å¼¦ç›¸ä¼¼åº¦è¨ˆç®—
    cosineSimilarity(vectorA: number[], vectorB: number[]): number {
        const dotProduct = vectorA.reduce((sum, a, i) => sum + a * vectorB[i], 0);
        const magnitudeA = Math.sqrt(vectorA.reduce((sum, a) => sum + a * a, 0));
        const magnitudeB = Math.sqrt(vectorB.reduce((sum, b) => sum + b * b, 0));
        
        return dotProduct / (magnitudeA * magnitudeB);
    }
    
    // æ­å¹¾é‡Œå¾—è·é›¢
    euclideanDistance(vectorA: number[], vectorB: number[]): number {
        return Math.sqrt(
            vectorA.reduce((sum, a, i) => sum + Math.pow(a - vectorB[i], 2), 0)
        );
    }
}
```

### 3. æ··åˆæœç´¢ç­–ç•¥

```typescript
class HybridSearchEngine {
    async search(
        query: string, 
        options: SearchOptions
    ): Promise<SearchResult[]> {
        // ä¸¦è¡ŒåŸ·è¡Œå¤šç¨®æœç´¢ç­–ç•¥
        const [
            semanticResults,
            tfidfResults,
            symbolResults
        ] = await Promise.all([
            this.semanticSearch(query),      // èªç¾©æœç´¢
            this.tfidfSearch(query),         // é—œéµè©æœç´¢  
            this.symbolSearch(query)         // ç¬¦è™Ÿæœç´¢
        ]);
        
        // çµæœèåˆå’Œé‡æ’åº
        return this.fusionRanking([
            ...semanticResults,
            ...tfidfResults,
            ...symbolResults
        ]);
    }
    
    private fusionRanking(results: SearchResult[]): SearchResult[] {
        // å¯¦ç¾ RRF (Reciprocal Rank Fusion) ç®—æ³•
        const fusionScores = new Map<string, number>();
        
        results.forEach((result, rank) => {
            const score = 1 / (rank + 60); // RRF å…¬å¼
            fusionScores.set(
                result.id, 
                (fusionScores.get(result.id) || 0) + score
            );
        });
        
        return Array.from(fusionScores.entries())
            .sort(([,scoreA], [,scoreB]) => scoreB - scoreA)
            .map(([id]) => results.find(r => r.id === id)!);
    }
}
```

### 4. ä»£ç¢¼å¡Šæ™ºèƒ½åˆ†å‰²

```typescript
class CodeChunker {
    chunkDocument(document: TextDocument): CodeChunk[] {
        const chunks: CodeChunk[] = [];
        const ast = this.parseDocument(document);
        
        // æŒ‰å‡½æ•¸ã€é¡ã€æ¨¡çµ„ç­‰èªç¾©å–®ä½åˆ†å‰²
        ast.functions.forEach(func => {
            chunks.push({
                content: func.text,
                range: func.range,
                type: 'function',
                symbolName: func.name,
                dependencies: this.extractDependencies(func)
            });
        });
        
        ast.classes.forEach(cls => {
            chunks.push({
                content: cls.text,
                range: cls.range,
                type: 'class',
                symbolName: cls.name,
                methods: cls.methods.map(m => m.name)
            });
        });
        
        return chunks;
    }
}
```

## ğŸ” æœç´¢ç­–ç•¥è©³è§£

### 1. TF-IDF é—œéµè©æœç´¢

```typescript
class TfIdfSearch {
    private termFrequency = new Map<string, Map<string, number>>();
    private documentFrequency = new Map<string, number>();
    
    buildIndex(documents: Document[]): void {
        documents.forEach(doc => {
            const terms = this.tokenize(doc.content);
            const termCounts = new Map<string, number>();
            
            // è¨ˆç®—è©é » (TF)
            terms.forEach(term => {
                termCounts.set(term, (termCounts.get(term) || 0) + 1);
            });
            
            // è¨˜éŒ„æ–‡æª”é »ç‡ (DF)
            Array.from(termCounts.keys()).forEach(term => {
                this.documentFrequency.set(
                    term, 
                    (this.documentFrequency.get(term) || 0) + 1
                );
            });
            
            this.termFrequency.set(doc.id, termCounts);
        });
    }
    
    search(query: string, topK: number = 10): SearchResult[] {
        const queryTerms = this.tokenize(query);
        const scores = new Map<string, number>();
        
        queryTerms.forEach(term => {
            this.termFrequency.forEach((docTerms, docId) => {
                if (docTerms.has(term)) {
                    const tf = docTerms.get(term)!;
                    const df = this.documentFrequency.get(term)!;
                    const idf = Math.log(this.termFrequency.size / df);
                    const tfidf = tf * idf;
                    
                    scores.set(docId, (scores.get(docId) || 0) + tfidf);
                }
            });
        });
        
        return Array.from(scores.entries())
            .sort(([,scoreA], [,scoreB]) => scoreB - scoreA)
            .slice(0, topK)
            .map(([docId, score]) => ({ docId, score }));
    }
}
```

### 2. èªç¾©å‘é‡æœç´¢

```typescript
class SemanticVectorSearch {
    private index: VectorIndex;
    
    async search(query: string, topK: number = 10): Promise<SearchResult[]> {
        // ç”ŸæˆæŸ¥è©¢å‘é‡
        const queryVector = await this.embeddingProvider.computeEmbedding(query);
        
        // åœ¨å‘é‡ç©ºé–“ä¸­æœç´¢æœ€ç›¸ä¼¼çš„é …ç›®
        const candidates = await this.index.search(queryVector, topK * 2);
        
        // èªç¾©ç›¸ä¼¼åº¦éæ¿¾å’Œé‡æ’åº
        const results = candidates
            .filter(candidate => candidate.similarity > 0.7) // ç›¸ä¼¼åº¦é–¾å€¼
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, topK);
            
        return results;
    }
}
```

### 3. èªç¾©èšé¡åˆ†æ

```typescript
class SemanticClustering {
    clusterResults(results: SearchResult[]): ClusterGroup[] {
        const vectors = results.map(r => r.embedding);
        const clusters = this.kMeansClustering(vectors, 3);
        
        return clusters.map(cluster => ({
            theme: this.extractTheme(cluster),
            results: cluster.map(idx => results[idx]),
            coherenceScore: this.calculateCoherence(cluster)
        }));
    }
    
    private extractTheme(cluster: number[]): string {
        // å¾èšé¡ä¸­æå–ä¸»é¡Œé—œéµè©
        const texts = cluster.map(idx => this.results[idx].content);
        return this.extractKeywords(texts.join(' '));
    }
}
```

## ğŸ¯ æ™ºèƒ½æŸ¥è©¢æ“´å±•

### 1. åŒç¾©è©æ“´å±•

```typescript
class QueryExpansion {
    private synonyms = new Map<string, string[]>();
    
    expandQuery(originalQuery: string): string[] {
        const expandedQueries = [originalQuery];
        const terms = this.tokenize(originalQuery);
        
        terms.forEach(term => {
            const synonymList = this.synonyms.get(term);
            if (synonymList) {
                synonymList.forEach(synonym => {
                    const expandedQuery = originalQuery.replace(term, synonym);
                    expandedQueries.push(expandedQuery);
                });
            }
        });
        
        return expandedQueries;
    }
}
```

### 2. ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ“´å±•

```typescript
class ContextAwareExpansion {
    expandWithContext(
        query: string, 
        context: WorkspaceContext
    ): ExpandedQuery {
        const expansion = {
            originalQuery: query,
            expandedTerms: [] as string[],
            contextualHints: [] as string[]
        };
        
        // æ ¹æ“šç•¶å‰æ–‡ä»¶èªè¨€æ·»åŠ ä¸Šä¸‹æ–‡
        if (context.currentLanguage) {
            expansion.expandedTerms.push(
                ...this.getLanguageSpecificTerms(context.currentLanguage)
            );
        }
        
        // æ ¹æ“šé …ç›®é¡å‹æ·»åŠ ç›¸é—œè©å½™
        if (context.projectType) {
            expansion.contextualHints.push(
                ...this.getProjectTypeKeywords(context.projectType)
            );
        }
        
        return expansion;
    }
}
```

## ğŸ“Š çµæœè©•åˆ†å’Œæ’åº

### 1. å¤šç¶­åº¦è©•åˆ†ç³»çµ±

```typescript
interface ScoringDimensions {
    semanticSimilarity: number;    // èªç¾©ç›¸ä¼¼åº¦ (0-1)
    keywordMatch: number;          // é—œéµè©åŒ¹é…åº¦ (0-1)
    contextRelevance: number;      // ä¸Šä¸‹æ–‡ç›¸é—œæ€§ (0-1)
    recency: number;               // æ™‚é–“æ–°è¿‘æ€§ (0-1)
    popularity: number;            // ä½¿ç”¨é »ç‡ (0-1)
}

class MultiDimensionalScoring {
    calculateFinalScore(
        result: SearchResult, 
        dimensions: ScoringDimensions,
        weights: ScoringWeights
    ): number {
        return (
            dimensions.semanticSimilarity * weights.semantic +
            dimensions.keywordMatch * weights.keyword +
            dimensions.contextRelevance * weights.context +
            dimensions.recency * weights.recency +
            dimensions.popularity * weights.popularity
        );
    }
}
```

### 2. å­¸ç¿’å‹æ’åºå„ªåŒ–

```typescript
class LearningToRank {
    private clickThroughData = new Map<string, number>();
    private userFeedback = new Map<string, number>();
    
    updateRanking(
        results: SearchResult[], 
        userInteraction: UserInteraction
    ): SearchResult[] {
        // æ ¹æ“šç”¨æˆ¶é»æ“Šå’Œåé¥‹èª¿æ•´æ’åº
        results.forEach(result => {
            const clickScore = this.clickThroughData.get(result.id) || 0;
            const feedbackScore = this.userFeedback.get(result.id) || 0;
            
            result.learningScore = (clickScore * 0.6) + (feedbackScore * 0.4);
        });
        
        return results.sort((a, b) => 
            (b.similarityScore + b.learningScore) - 
            (a.similarityScore + a.learningScore)
        );
    }
}
```

## ğŸš€ æ€§èƒ½å„ªåŒ–æŠ€è¡“

### 1. å‘é‡ç´¢å¼•å„ªåŒ–

```typescript
class OptimizedVectorIndex {
    private hierarchicalIndex: Map<number, VectorNode[]>;
    private approximateIndex: AnnoyIndex;
    
    constructor() {
        // ä½¿ç”¨åˆ†å±¤ç´¢å¼•åŠ é€Ÿæœç´¢
        this.hierarchicalIndex = new Map();
        
        // ä½¿ç”¨è¿‘ä¼¼æœ€è¿‘é„°åŠ é€Ÿå¤§è¦æ¨¡æœç´¢
        this.approximateIndex = new AnnoyIndex(1536, 'angular');
    }
    
    async search(queryVector: number[], topK: number): Promise<SearchResult[]> {
        // é¦–å…ˆä½¿ç”¨è¿‘ä¼¼ç´¢å¼•å¿«é€Ÿéæ¿¾
        const candidates = this.approximateIndex.getNNsByVector(
            queryVector, 
            topK * 3
        );
        
        // ç„¶å¾Œä½¿ç”¨ç²¾ç¢ºè¨ˆç®—é‡æ’åº
        const preciseResults = candidates.map(candidateId => {
            const candidateVector = this.getVector(candidateId);
            const similarity = this.cosineSimilarity(queryVector, candidateVector);
            return { id: candidateId, similarity };
        });
        
        return preciseResults
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, topK);
    }
}
```

### 2. å¢é‡ç´¢å¼•æ›´æ–°

```typescript
class IncrementalIndexing {
    private pendingUpdates = new Set<string>();
    private updateBatchSize = 100;
    
    async updateDocument(documentId: string, content: string): Promise<void> {
        this.pendingUpdates.add(documentId);
        
        // æ‰¹é‡è™•ç†æ›´æ–°ä»¥æé«˜æ•ˆç‡
        if (this.pendingUpdates.size >= this.updateBatchSize) {
            await this.processBatchUpdates();
        }
    }
    
    private async processBatchUpdates(): Promise<void> {
        const updates = Array.from(this.pendingUpdates);
        this.pendingUpdates.clear();
        
        // ä¸¦è¡Œè™•ç†å¤šå€‹æ–‡æª”çš„åµŒå…¥è¨ˆç®—
        const embeddings = await Promise.all(
            updates.map(docId => this.computeEmbedding(docId))
        );
        
        // æ‰¹é‡æ›´æ–°ç´¢å¼•
        await this.index.batchUpdate(updates, embeddings);
    }
}
```

### 3. æ™ºèƒ½å¿«å–ç­–ç•¥

```typescript
class SemanticCache {
    private queryCache = new LRUCache<string, SearchResult[]>(1000);
    private embeddingCache = new LRUCache<string, number[]>(10000);
    
    async getCachedResults(query: string): Promise<SearchResult[] | null> {
        // æª¢æŸ¥å®Œå…¨åŒ¹é…çš„å¿«å–
        const exactMatch = this.queryCache.get(query);
        if (exactMatch) return exactMatch;
        
        // æª¢æŸ¥èªç¾©ç›¸ä¼¼çš„æŸ¥è©¢å¿«å–
        const similarQueries = await this.findSimilarQueries(query);
        for (const similarQuery of similarQueries) {
            const cachedResults = this.queryCache.get(similarQuery.text);
            if (cachedResults && similarQuery.similarity > 0.9) {
                return cachedResults;
            }
        }
        
        return null;
    }
}
```

## ğŸ¯ å¯¦éš›æ‡‰ç”¨æ•ˆæœ

### 1. æ™ºèƒ½ä»£ç¢¼æœç´¢
- **è‡ªç„¶èªè¨€æŸ¥è©¢**: "Find functions that handle user authentication"
- **èªç¾©ç†è§£**: ç³»çµ±ç†è§£ "authentication" åŒ…å« login, signin, auth ç­‰ç›¸é—œæ¦‚å¿µ
- **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**: æ ¹æ“šç•¶å‰é …ç›®é¡å‹èª¿æ•´æœç´¢ç¯„åœ

### 2. ç›¸é—œæ€§æå‡
- **å‚³çµ±é—œéµè©æœç´¢**: åªèƒ½åŒ¹é…ç¢ºåˆ‡çš„è©å½™
- **èªç¾©å¢å¼·æœç´¢**: ç†è§£æ¦‚å¿µå’Œæ„åœ–ï¼Œæ‰¾åˆ°èªç¾©ç›¸é—œçš„å…§å®¹
- **æ··åˆç­–ç•¥**: çµåˆç²¾ç¢ºåŒ¹é…å’Œèªç¾©ç†è§£çš„å„ªå‹¢

### 3. çµæœè³ªé‡æ”¹å–„
- **å»é‡è¤‡**: æ™ºèƒ½è­˜åˆ¥å’Œåˆä½µç›¸ä¼¼çš„æœç´¢çµæœ
- **æ’åºå„ªåŒ–**: å¤šç¶­åº¦è©•åˆ†ç¢ºä¿æœ€ç›¸é—œçš„çµæœæ’åœ¨å‰é¢
- **èšé¡å±•ç¤º**: å°‡ç›¸é—œçµæœåˆ†çµ„ï¼Œå¹«åŠ©ç”¨æˆ¶å¿«é€Ÿç†è§£

## ğŸ”® æœªä¾†ç™¼å±•æ–¹å‘

1. **å¤šæ¨¡æ…‹ç†è§£** - æ”¯æŒä»£ç¢¼ã€æ–‡æª”ã€åœ–åƒç­‰å¤šç¨®å…§å®¹é¡å‹çš„èªç¾©æœç´¢
2. **å€‹æ€§åŒ–å­¸ç¿’** - æ ¹æ“šç”¨æˆ¶è¡Œç‚ºå’Œåå¥½èª¿æ•´èªç¾©ç†è§£æ¨¡å‹
3. **å¯¦æ™‚æ›´æ–°** - æ”¯æŒä»£ç¢¼è®Šæ›´çš„å¯¦æ™‚èªç¾©ç´¢å¼•æ›´æ–°
4. **è·¨èªè¨€ç†è§£** - æ”¯æŒå¤šç¨®ç¨‹å¼èªè¨€çš„çµ±ä¸€èªç¾©æœç´¢
