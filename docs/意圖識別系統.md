# æ„åœ–è­˜åˆ¥ç³»çµ± (Intent Recognition)

## ğŸ¯ ç³»çµ±æ¦‚è¿°

æ„åœ–è­˜åˆ¥ç³»çµ±æ˜¯ VS Code Copilot Chat çš„æ™ºèƒ½ç†è§£æ ¸å¿ƒï¼Œå®ƒèƒ½å¤ åˆ†æç”¨æˆ¶çš„è‡ªç„¶èªè¨€è¼¸å…¥ï¼Œæº–ç¢ºè­˜åˆ¥ç”¨æˆ¶çš„çœŸå¯¦æ„åœ–å’Œéœ€æ±‚ï¼Œä¸¦å°‡å…¶æ˜ å°„åˆ°å…·é«”çš„æ“ä½œé¡å‹å’Œåƒæ•¸ï¼Œç¢ºä¿ AI åŠ©æ‰‹èƒ½å¤ åŸ·è¡Œæ­£ç¢ºçš„ä»»å‹™ä¸¦æä¾›æœ€é©åˆçš„å›æ‡‰ã€‚

## ğŸ”„ ç³»çµ±æ¶æ§‹æµç¨‹åœ–

```mermaid
flowchart TD
    A[ç”¨æˆ¶è¼¸å…¥] --> B[è¼¸å…¥é è™•ç†å™¨]
    B --> C[èªè¨€åˆ†æå™¨]
    
    C --> D[è©æ³•åˆ†æ]
    C --> E[å¥æ³•åˆ†æ] 
    C --> F[èªç¾©åˆ†æ]
    
    D --> G[é—œéµè©æå–]
    E --> H[å‹•è©è­˜åˆ¥]
    F --> I[å¯¦é«”æå–]
    
    G --> J[æ„åœ–åˆ†é¡å™¨]
    H --> J
    I --> J
    
    J --> K{ä¸»è¦æ„åœ–é¡åˆ¥}
    
    K -->|ä»£ç¢¼æ“ä½œ| L[CodeIntent]
    K -->|è§£é‡‹èªªæ˜| M[ExplainIntent]
    K -->|å·¥ä½œå€æ“ä½œ| N[WorkspaceIntent]
    K -->|æ–‡ä»¶æ“ä½œ| O[FileIntent]
    K -->|å•ç­”å°è©±| P[ChatIntent]
    K -->|å·¥å…·èª¿ç”¨| Q[ToolIntent]
    
    L --> R[ä»£ç¢¼æ“ä½œå­åˆ†é¡]
    M --> S[è§£é‡‹é¡å‹è­˜åˆ¥]
    N --> T[å·¥ä½œå€æ“ä½œåˆ†æ]
    O --> U[æ–‡ä»¶æ“ä½œåˆ†æ]
    P --> V[å°è©±ä¸Šä¸‹æ–‡åˆ†æ]
    Q --> W[å·¥å…·åƒæ•¸æå–]
    
    R --> X[åƒæ•¸æå–å™¨]
    S --> X
    T --> X
    U --> X
    V --> X
    W --> X
    
    X --> Y[ç½®ä¿¡åº¦è©•ä¼°]
    Y --> Z{ç½®ä¿¡åº¦æª¢æŸ¥}
    
    Z -->|é«˜ç½®ä¿¡åº¦| AA[æ„åœ–ç¢ºèª]
    Z -->|ä½ç½®ä¿¡åº¦| BB[æ¾„æ¸…è«‹æ±‚ç”Ÿæˆ]
    
    BB --> CC[åå•ç”¨æˆ¶]
    CC --> DD[ç­‰å¾…ç”¨æˆ¶å›æ‡‰]
    DD --> A
    
    AA --> EE[æ„åœ–åŸ·è¡Œå™¨é¸æ“‡]
    EE --> FF[åƒæ•¸é©—è­‰]
    FF --> GG[åŸ·è¡Œè¨ˆåŠƒç”Ÿæˆ]
    GG --> HH[å‚³éçµ¦å°æ‡‰è™•ç†å™¨]
```

## ğŸ§© æ ¸å¿ƒçµ„ä»¶

### 1. æ„åœ–åˆ†é¡ç³»çµ±
**ä½ç½®**: `src/extension/intents/`

**åŠŸèƒ½**:
- è­˜åˆ¥ç”¨æˆ¶æŸ¥è©¢çš„ä¸»è¦æ„åœ–é¡å‹
- æ”¯æŒå¤šå±¤æ¬¡æ„åœ–åˆ†é¡
- æä¾›ç½®ä¿¡åº¦è©•åˆ†

**é—œéµæ–‡ä»¶**:
- `intentHandler.ts` - æ„åœ–è™•ç†å™¨ä»‹é¢
- `defaultIntentRequestHandler.ts` - é è¨­æ„åœ–è™•ç†å™¨
- `intentInvocation.ts` - æ„åœ–èª¿ç”¨ç®¡ç†

### 2. èŠå¤©åƒèˆ‡è€…ç³»çµ±
**ä½ç½®**: `src/extension/conversation/`

**åŠŸèƒ½**:
- è™•ç†ä¸åŒé¡å‹çš„èŠå¤©äº’å‹•
- æ”¯æ´ @ ç¬¦è™Ÿè§¸ç™¼çš„ç‰¹å®šæ„åœ–
- ç®¡ç†èŠå¤©åƒèˆ‡è€…ç”Ÿå‘½é€±æœŸ

**é—œéµåƒèˆ‡è€…**:
- **@workspace** - å·¥ä½œå€æ“ä½œ
- **@vscode** - VS Code åŠŸèƒ½æ“ä½œ
- **@terminal** - çµ‚ç«¯æ©Ÿæ“ä½œ
- **@github** - GitHub æ•´åˆ

### 3. æŒ‡ä»¤è§£æå™¨
**ä½ç½®**: `src/extension/prompt/`

**åŠŸèƒ½**:
- è§£ææ–œç·šæŒ‡ä»¤ (slash commands)
- æå–æŒ‡ä»¤åƒæ•¸å’Œé¸é …
- é©—è­‰æŒ‡ä»¤æ ¼å¼å’Œæ¬Šé™

**æ”¯æ´æŒ‡ä»¤**:
- `/explain` - è§£é‡‹ä»£ç¢¼
- `/fix` - ä¿®å¾©å•é¡Œ
- `/tests` - ç”Ÿæˆæ¸¬è©¦
- `/doc` - ç”Ÿæˆæ–‡æª”

### 4. è®Šæ•¸ç³»çµ±
**åŠŸèƒ½**:
- è­˜åˆ¥å’Œè™•ç† # è®Šæ•¸å¼•ç”¨
- è‡ªå‹•è§£ææ–‡ä»¶ã€é¸å–ç¯„åœã€ç¬¦è™Ÿç­‰
- æä¾›ä¸Šä¸‹æ–‡ç›¸é—œçš„è®Šæ•¸å»ºè­°

## ğŸ’¡ æ„åœ–åˆ†é¡è©³è§£

### 1. ä»£ç¢¼æ„åœ– (Code Intent)

```typescript
enum CodeIntentType {
    CREATE = 'create',           // å‰µå»ºæ–°ä»£ç¢¼
    MODIFY = 'modify',           // ä¿®æ”¹ç¾æœ‰ä»£ç¢¼
    REFACTOR = 'refactor',       // é‡æ§‹ä»£ç¢¼
    FIX = 'fix',                 // ä¿®å¾©éŒ¯èª¤
    OPTIMIZE = 'optimize',       // å„ªåŒ–æ€§èƒ½
    TEST = 'test',               // ç”Ÿæˆæ¸¬è©¦
    DOCUMENT = 'document'        // ç”Ÿæˆæ–‡æª”
}

class CodeIntentRecognizer {
    private readonly actionVerbs = new Map<string, CodeIntentType>([
        ['create', CodeIntentType.CREATE],
        ['write', CodeIntentType.CREATE],
        ['generate', CodeIntentType.CREATE],
        ['add', CodeIntentType.CREATE],
        
        ['modify', CodeIntentType.MODIFY],
        ['change', CodeIntentType.MODIFY],
        ['update', CodeIntentType.MODIFY],
        ['edit', CodeIntentType.MODIFY],
        
        ['refactor', CodeIntentType.REFACTOR],
        ['restructure', CodeIntentType.REFACTOR],
        ['reorganize', CodeIntentType.REFACTOR],
        
        ['fix', CodeIntentType.FIX],
        ['repair', CodeIntentType.FIX],
        ['correct', CodeIntentType.FIX],
        ['debug', CodeIntentType.FIX],
        
        ['optimize', CodeIntentType.OPTIMIZE],
        ['improve', CodeIntentType.OPTIMIZE],
        ['enhance', CodeIntentType.OPTIMIZE],
        
        ['test', CodeIntentType.TEST],
        ['verify', CodeIntentType.TEST],
        ['validate', CodeIntentType.TEST],
        
        ['document', CodeIntentType.DOCUMENT],
        ['comment', CodeIntentType.DOCUMENT],
        ['explain', CodeIntentType.DOCUMENT]
    ]);
    
    recognizeIntent(query: string): CodeIntent | null {
        const tokens = this.tokenize(query.toLowerCase());
        
        for (const token of tokens) {
            const intentType = this.actionVerbs.get(token);
            if (intentType) {
                return {
                    type: intentType,
                    confidence: this.calculateConfidence(query, intentType),
                    parameters: this.extractParameters(query, intentType)
                };
            }
        }
        
        return null;
    }
}
```

### 2. è§£é‡‹æ„åœ– (Explain Intent)

```typescript
enum ExplainIntentType {
    CODE_EXPLANATION = 'code_explanation',         // è§£é‡‹ä»£ç¢¼åŠŸèƒ½
    ERROR_EXPLANATION = 'error_explanation',       // è§£é‡‹éŒ¯èª¤åŸå› 
    CONCEPT_EXPLANATION = 'concept_explanation',   // è§£é‡‹ç¨‹å¼æ¦‚å¿µ
    API_EXPLANATION = 'api_explanation',           // è§£é‡‹ API ç”¨æ³•
    PATTERN_EXPLANATION = 'pattern_explanation'    // è§£é‡‹è¨­è¨ˆæ¨¡å¼
}

class ExplainIntentRecognizer {
    private readonly explainKeywords = [
        'explain', 'what', 'how', 'why', 'describe',
        'clarify', 'elaborate', 'detail', 'break down'
    ];
    
    private readonly questionPatterns = [
        /^what (is|does|are)/i,
        /^how (does|do|can|to)/i,
        /^why (is|does|do)/i,
        /can you explain/i,
        /what's the purpose of/i,
        /how does.*work/i
    ];
    
    recognizeIntent(query: string, context: IntentContext): ExplainIntent | null {
        const hasExplainKeyword = this.explainKeywords.some(
            keyword => query.toLowerCase().includes(keyword)
        );
        
        const matchesQuestionPattern = this.questionPatterns.some(
            pattern => pattern.test(query)
        );
        
        if (hasExplainKeyword || matchesQuestionPattern) {
            const subType = this.determineExplainType(query, context);
            
            return {
                type: ExplainIntentType.CODE_EXPLANATION,
                subType,
                confidence: this.calculateConfidence(query),
                target: this.extractTarget(query, context)
            };
        }
        
        return null;
    }
    
    private determineExplainType(query: string, context: IntentContext): ExplainIntentType {
        // æª¢æŸ¥æ˜¯å¦æœ‰éŒ¯èª¤è¨ºæ–·ä¿¡æ¯
        if (context.diagnostics && context.diagnostics.length > 0) {
            return ExplainIntentType.ERROR_EXPLANATION;
        }
        
        // æª¢æŸ¥æ˜¯å¦æåˆ° API ç›¸é—œè©å½™
        if (/\b(api|function|method|library|framework)\b/i.test(query)) {
            return ExplainIntentType.API_EXPLANATION;
        }
        
        // æª¢æŸ¥æ˜¯å¦æåˆ°è¨­è¨ˆæ¨¡å¼
        if (/\b(pattern|design|architecture|structure)\b/i.test(query)) {
            return ExplainIntentType.PATTERN_EXPLANATION;
        }
        
        // æª¢æŸ¥æ˜¯å¦æåˆ°ç¨‹å¼æ¦‚å¿µ
        if (/\b(concept|principle|theory|algorithm)\b/i.test(query)) {
            return ExplainIntentType.CONCEPT_EXPLANATION;
        }
        
        return ExplainIntentType.CODE_EXPLANATION;
    }
}
```

### 3. å·¥ä½œå€æ„åœ– (Workspace Intent)

```typescript
enum WorkspaceIntentType {
    SEARCH = 'search',           // æœç´¢å·¥ä½œå€å…§å®¹
    NAVIGATE = 'navigate',       // å°èˆªåˆ°ç‰¹å®šä½ç½®
    STRUCTURE = 'structure',     // æŸ¥çœ‹é …ç›®çµæ§‹
    REFACTOR = 'refactor',       // å·¥ä½œå€ç´šåˆ¥é‡æ§‹
    ANALYZE = 'analyze',         // åˆ†æé …ç›®
    SETUP = 'setup'              // é …ç›®è¨­ç½®
}

class WorkspaceIntentRecognizer {
    private readonly workspaceKeywords = new Map<string, WorkspaceIntentType>([
        ['search', WorkspaceIntentType.SEARCH],
        ['find', WorkspaceIntentType.SEARCH],
        ['locate', WorkspaceIntentType.SEARCH],
        ['look for', WorkspaceIntentType.SEARCH],
        
        ['navigate', WorkspaceIntentType.NAVIGATE],
        ['go to', WorkspaceIntentType.NAVIGATE],
        ['show me', WorkspaceIntentType.NAVIGATE],
        ['open', WorkspaceIntentType.NAVIGATE],
        
        ['structure', WorkspaceIntentType.STRUCTURE],
        ['organization', WorkspaceIntentType.STRUCTURE],
        ['layout', WorkspaceIntentType.STRUCTURE],
        ['hierarchy', WorkspaceIntentType.STRUCTURE],
        
        ['analyze', WorkspaceIntentType.ANALYZE],
        ['review', WorkspaceIntentType.ANALYZE],
        ['examine', WorkspaceIntentType.ANALYZE],
        ['audit', WorkspaceIntentType.ANALYZE]
    ]);
    
    recognizeIntent(query: string): WorkspaceIntent | null {
        for (const [keyword, type] of this.workspaceKeywords) {
            if (query.toLowerCase().includes(keyword)) {
                return {
                    type,
                    scope: this.extractScope(query),
                    target: this.extractTarget(query),
                    confidence: this.calculateConfidence(query, keyword)
                };
            }
        }
        
        return null;
    }
    
    private extractScope(query: string): WorkspaceScope {
        if (/\b(entire|whole|all|complete)\b/i.test(query)) {
            return WorkspaceScope.ENTIRE;
        }
        
        if (/\b(current|this|active)\b/i.test(query)) {
            return WorkspaceScope.CURRENT;
        }
        
        if (/\b(folder|directory|package)\b/i.test(query)) {
            return WorkspaceScope.FOLDER;
        }
        
        return WorkspaceScope.AUTO;
    }
}
```

## ğŸ¯ ä¸Šä¸‹æ–‡æ„ŸçŸ¥è­˜åˆ¥

### 1. ä¸Šä¸‹æ–‡ä¿¡æ¯æ”¶é›†

```typescript
interface IntentContext {
    // ç·¨è¼¯å™¨ä¸Šä¸‹æ–‡
    activeEditor?: {
        document: TextDocument;
        selection: Selection;
        language: string;
        cursorPosition: Position;
    };
    
    // å·¥ä½œå€ä¸Šä¸‹æ–‡
    workspace?: {
        folders: WorkspaceFolder[];
        files: Uri[];
        projectType: string;
        frameworks: string[];
    };
    
    // è¨ºæ–·ä¿¡æ¯
    diagnostics?: Diagnostic[];
    
    // èŠå¤©æ­·å²
    conversationHistory?: ChatMessage[];
    
    // æœ€è¿‘æ“ä½œ
    recentActions?: RecentAction[];
}

class ContextAwareIntentRecognizer {
    recognizeWithContext(query: string, context: IntentContext): Intent {
        // åŸºç¤æ„åœ–è­˜åˆ¥
        const baseIntent = this.recognizeBaseIntent(query);
        
        // æ ¹æ“šä¸Šä¸‹æ–‡èª¿æ•´æ„åœ–
        const adjustedIntent = this.adjustIntentWithContext(baseIntent, context);
        
        // æå–ä¸Šä¸‹æ–‡ç›¸é—œåƒæ•¸
        const contextualParameters = this.extractContextualParameters(
            adjustedIntent, 
            context
        );
        
        return {
            ...adjustedIntent,
            parameters: { ...adjustedIntent.parameters, ...contextualParameters },
            contextConfidence: this.calculateContextConfidence(adjustedIntent, context)
        };
    }
    
    private adjustIntentWithContext(
        intent: Intent, 
        context: IntentContext
    ): Intent {
        // å¦‚æœæœ‰è¨ºæ–·éŒ¯èª¤ï¼Œå‚¾å‘æ–¼ä¿®å¾©æ„åœ–
        if (context.diagnostics?.length > 0 && intent.type === 'general') {
            return {
                ...intent,
                type: 'fix',
                confidence: Math.min(intent.confidence + 0.3, 1.0)
            };
        }
        
        // å¦‚æœæœ‰é¸å–çš„ä»£ç¢¼ï¼Œå‚¾å‘æ–¼ä»£ç¢¼ç›¸é—œæ“ä½œ
        if (context.activeEditor?.selection && !context.activeEditor.selection.isEmpty) {
            if (intent.type === 'general') {
                return {
                    ...intent,
                    type: 'explain',
                    target: 'selection',
                    confidence: Math.min(intent.confidence + 0.2, 1.0)
                };
            }
        }
        
        return intent;
    }
}
```

### 2. å‹•æ…‹åƒæ•¸æå–

```typescript
class ParameterExtractor {
    extractParameters(query: string, intent: Intent, context: IntentContext): IntentParameters {
        const parameters: IntentParameters = {};
        
        // æå–æ–‡ä»¶ç›¸é—œåƒæ•¸
        parameters.files = this.extractFileReferences(query, context);
        
        // æå–ç¯„åœåƒæ•¸
        parameters.range = this.extractRangeReferences(query, context);
        
        // æå–èªè¨€åƒæ•¸
        parameters.language = this.extractLanguage(query, context);
        
        // æå–é¸é …åƒæ•¸
        parameters.options = this.extractOptions(query);
        
        return parameters;
    }
    
    private extractFileReferences(query: string, context: IntentContext): FileReference[] {
        const fileReferences: FileReference[] = [];
        
        // æŸ¥æ‰¾ #file: å¼•ç”¨
        const filePattern = /#file:([^\s]+)/g;
        let match;
        while ((match = filePattern.exec(query)) !== null) {
            fileReferences.push({
                type: 'explicit',
                path: match[1],
                source: 'hashtag'
            });
        }
        
        // æŸ¥æ‰¾ç•¶å‰æ–‡ä»¶å¼•ç”¨
        if (/\b(this file|current file|here)\b/i.test(query) && context.activeEditor) {
            fileReferences.push({
                type: 'current',
                document: context.activeEditor.document,
                source: 'context'
            });
        }
        
        return fileReferences;
    }
    
    private extractRangeReferences(query: string, context: IntentContext): RangeReference[] {
        const rangeReferences: RangeReference[] = [];
        
        // æŸ¥æ‰¾ #selection å¼•ç”¨
        if (/\b(#selection|selected code|this selection)\b/i.test(query)) {
            if (context.activeEditor && !context.activeEditor.selection.isEmpty) {
                rangeReferences.push({
                    type: 'selection',
                    range: context.activeEditor.selection,
                    document: context.activeEditor.document
                });
            }
        }
        
        // æŸ¥æ‰¾è¡Œè™Ÿå¼•ç”¨
        const linePattern = /line (\d+)(?:-(\d+))?/gi;
        let match;
        while ((match = linePattern.exec(query)) !== null) {
            const startLine = parseInt(match[1]) - 1; // VS Code ä½¿ç”¨ 0-based è¡Œè™Ÿ
            const endLine = match[2] ? parseInt(match[2]) - 1 : startLine;
            
            rangeReferences.push({
                type: 'line',
                range: new Range(startLine, 0, endLine, Number.MAX_VALUE),
                document: context.activeEditor?.document
            });
        }
        
        return rangeReferences;
    }
}
```

## ğŸ”§ ç½®ä¿¡åº¦è©•ä¼°ç³»çµ±

### 1. å¤šå› å­ç½®ä¿¡åº¦è¨ˆç®—

```typescript
class ConfidenceCalculator {
    calculateConfidence(intent: Intent, context: IntentContext): number {
        const factors = {
            keywordMatch: this.calculateKeywordConfidence(intent),
            contextMatch: this.calculateContextConfidence(intent, context),
            syntaxMatch: this.calculateSyntaxConfidence(intent),
            historicalMatch: this.calculateHistoricalConfidence(intent, context),
            semanticMatch: this.calculateSemanticConfidence(intent)
        };
        
        // åŠ æ¬Šå¹³å‡è¨ˆç®—ç¸½ç½®ä¿¡åº¦
        const weights = {
            keywordMatch: 0.25,
            contextMatch: 0.30,
            syntaxMatch: 0.15,
            historicalMatch: 0.15,
            semanticMatch: 0.15
        };
        
        return Object.entries(factors).reduce(
            (total, [factor, score]) => total + score * weights[factor],
            0
        );
    }
    
    private calculateContextConfidence(intent: Intent, context: IntentContext): number {
        let confidence = 0.5; // åŸºç¤ç½®ä¿¡åº¦
        
        // ä¸Šä¸‹æ–‡ä¸€è‡´æ€§åŠ åˆ†
        if (intent.type === 'fix' && context.diagnostics?.length > 0) {
            confidence += 0.3;
        }
        
        if (intent.type === 'explain' && context.activeEditor?.selection) {
            confidence += 0.2;
        }
        
        if (intent.type === 'workspace' && context.workspace?.folders.length > 0) {
            confidence += 0.2;
        }
        
        return Math.min(confidence, 1.0);
    }
    
    private calculateHistoricalConfidence(intent: Intent, context: IntentContext): number {
        // æ ¹æ“šç”¨æˆ¶æ­·å²è¡Œç‚ºèª¿æ•´ç½®ä¿¡åº¦
        const recentIntents = context.conversationHistory
            ?.slice(-5)
            .map(msg => msg.intent)
            .filter(Boolean);
            
        if (!recentIntents?.length) return 0.5;
        
        const sameTypeCount = recentIntents.filter(
            recentIntent => recentIntent.type === intent.type
        ).length;
        
        return 0.3 + (sameTypeCount / recentIntents.length) * 0.4;
    }
}
```

### 2. æ¾„æ¸…è«‹æ±‚ç”Ÿæˆ

```typescript
class ClarificationGenerator {
    generateClarification(intent: Intent, ambiguities: Ambiguity[]): ClarificationRequest {
        if (intent.confidence < 0.6) {
            return this.generateLowConfidenceClarification(intent);
        }
        
        if (ambiguities.length > 0) {
            return this.generateAmbiguityClarification(ambiguities);
        }
        
        return null;
    }
    
    private generateLowConfidenceClarification(intent: Intent): ClarificationRequest {
        const possibleIntents = this.getSimilarIntents(intent);
        
        return {
            type: 'multiple_choice',
            message: "I'm not sure what you'd like me to do. Did you mean:",
            options: possibleIntents.map(possibleIntent => ({
                label: this.getIntentLabel(possibleIntent),
                description: this.getIntentDescription(possibleIntent),
                intent: possibleIntent
            }))
        };
    }
    
    private generateAmbiguityClarification(ambiguities: Ambiguity[]): ClarificationRequest {
        const primaryAmbiguity = ambiguities[0];
        
        switch (primaryAmbiguity.type) {
            case 'file_reference':
                return {
                    type: 'file_selection',
                    message: "Which file would you like me to work with?",
                    candidates: primaryAmbiguity.candidates,
                    allowMultiple: primaryAmbiguity.allowMultiple
                };
                
            case 'scope_ambiguity':
                return {
                    type: 'scope_selection',
                    message: "What scope should I focus on?",
                    options: [
                        { label: "Current file", value: "current" },
                        { label: "Current folder", value: "folder" },
                        { label: "Entire workspace", value: "workspace" }
                    ]
                };
                
            default:
                return {
                    type: 'open_ended',
                    message: "Could you provide more details about what you'd like me to do?"
                };
        }
    }
}
```

## ğŸš€ å­¸ç¿’å’Œé©æ‡‰æ©Ÿåˆ¶

### 1. ç”¨æˆ¶è¡Œç‚ºå­¸ç¿’

```typescript
class IntentLearningSystem {
    private userPatterns = new Map<string, UserIntentPattern>();
    
    recordUserInteraction(
        originalQuery: string,
        recognizedIntent: Intent,
        userFeedback: UserFeedback
    ): void {
        const pattern = this.userPatterns.get(originalQuery) || {
            query: originalQuery,
            attempts: [],
            successfulIntent: null,
            confidence: 0
        };
        
        pattern.attempts.push({
            intent: recognizedIntent,
            feedback: userFeedback,
            timestamp: new Date()
        });
        
        if (userFeedback.type === 'positive') {
            pattern.successfulIntent = recognizedIntent;
            pattern.confidence = Math.min(pattern.confidence + 0.1, 1.0);
        } else if (userFeedback.type === 'negative') {
            pattern.confidence = Math.max(pattern.confidence - 0.05, 0);
        }
        
        this.userPatterns.set(originalQuery, pattern);
    }
    
    getPersonalizedIntent(query: string): Intent | null {
        // æŸ¥æ‰¾å®Œå…¨åŒ¹é…çš„å­¸ç¿’æ¨¡å¼
        const exactPattern = this.userPatterns.get(query);
        if (exactPattern?.successfulIntent && exactPattern.confidence > 0.7) {
            return exactPattern.successfulIntent;
        }
        
        // æŸ¥æ‰¾ç›¸ä¼¼æ¨¡å¼
        const similarPatterns = this.findSimilarPatterns(query);
        return this.combinePatterns(similarPatterns);
    }
}
```

### 2. å‹•æ…‹è¦å‰‡èª¿æ•´

```typescript
class AdaptiveIntentRules {
    private rules = new Map<string, IntentRule>();
    
    updateRulesBasedOnUsage(usageStats: UsageStatistics): void {
        // æ ¹æ“šä½¿ç”¨çµ±è¨ˆèª¿æ•´è¦å‰‡æ¬Šé‡
        usageStats.intentFrequency.forEach((frequency, intentType) => {
            const rule = this.rules.get(intentType);
            if (rule) {
                // æé«˜å¸¸ç”¨æ„åœ–çš„è­˜åˆ¥æ¬Šé‡
                rule.weight = Math.min(rule.weight + frequency * 0.01, 2.0);
            }
        });
        
        // èª¿æ•´é—œéµè©æ¬Šé‡
        usageStats.keywordSuccess.forEach((successRate, keyword) => {
            const relatedRules = this.findRulesWithKeyword(keyword);
            relatedRules.forEach(rule => {
                rule.keywordWeights.set(keyword, successRate);
            });
        });
    }
}
```

## ğŸ¯ å¯¦éš›æ‡‰ç”¨ç¤ºä¾‹

### 1. è¤‡é›œæŸ¥è©¢è§£æ

```typescript
// è¼¸å…¥: "Fix the authentication bug in the login component and add tests"
const complexQuery = "Fix the authentication bug in the login component and add tests";

const recognitionResult = {
    primaryIntent: {
        type: 'fix',
        confidence: 0.85,
        target: 'authentication bug',
        scope: 'login component'
    },
    secondaryIntent: {
        type: 'test',
        confidence: 0.90,
        target: 'login component',
        relationship: 'after_primary'
    },
    parameters: {
        files: ['login.ts', 'auth.service.ts'],
        testType: 'unit',
        priority: 'primary_first'
    }
};
```

### 2. ä¸Šä¸‹æ–‡é©…å‹•è­˜åˆ¥

```typescript
// æƒ…å¢ƒï¼šç”¨æˆ¶é¸æ“‡äº†æœ‰éŒ¯èª¤çš„ä»£ç¢¼
const contextualRecognition = {
    query: "What's wrong here?",
    context: {
        selection: "function login(user) { return user.authenticate(); }",
        diagnostics: [
            { message: "Property 'authenticate' does not exist", severity: 'error' }
        ]
    },
    result: {
        type: 'explain',
        subType: 'error_explanation',
        confidence: 0.95,
        target: 'type_error',
        suggestedActions: ['fix', 'type_definition']
    }
};
```

## ğŸ“Š æ€§èƒ½ç›£æ§å’Œå„ªåŒ–

### 1. è­˜åˆ¥æº–ç¢ºç‡è¿½è¹¤

```typescript
class IntentAccuracyTracker {
    private metrics = {
        totalQueries: 0,
        correctIdentifications: 0,
        userCorrections: 0,
        clarificationRequests: 0
    };
    
    recordAccuracy(query: string, intent: Intent, userFeedback: UserFeedback): void {
        this.metrics.totalQueries++;
        
        if (userFeedback.type === 'positive') {
            this.metrics.correctIdentifications++;
        } else if (userFeedback.type === 'correction') {
            this.metrics.userCorrections++;
        }
        
        if (intent.requiresClarification) {
            this.metrics.clarificationRequests++;
        }
    }
    
    getAccuracyReport(): AccuracyReport {
        return {
            overallAccuracy: this.metrics.correctIdentifications / this.metrics.totalQueries,
            clarificationRate: this.metrics.clarificationRequests / this.metrics.totalQueries,
            correctionRate: this.metrics.userCorrections / this.metrics.totalQueries
        };
    }
}
```

## ğŸ”® æœªä¾†ç™¼å±•æ–¹å‘

1. **æ·±åº¦å­¸ç¿’æ¨¡å‹** - æ•´åˆæ›´å…ˆé€²çš„ NLP æ¨¡å‹é€²è¡Œæ„åœ–è­˜åˆ¥
2. **å¤šè¼ªå°è©±ç†è§£** - æ”¯æ´è¤‡é›œçš„å¤šè¼ªå°è©±ä¸­çš„æ„åœ–è¿½è¹¤
3. **å€‹æ€§åŒ–é©æ‡‰** - æ ¹æ“šå€‹äººä½¿ç”¨ç¿’æ…£èª¿æ•´è­˜åˆ¥ç­–ç•¥
4. **è·¨æ¨¡æ…‹ç†è§£** - çµåˆæ–‡å­—ã€ä»£ç¢¼ã€åœ–åƒç­‰å¤šç¨®è¼¸å…¥å½¢å¼
